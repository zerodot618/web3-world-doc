import Image from 'next/image';





## 双花攻击
数字货币和纸质货币区别是，数字货币可以复制，会产生**双花攻击(double spending attack)**。

去中心化货币要解决两个问题：

1. 数字货币的发行
2. 怎么验证交易的有效性，防止双花攻击(double spending attack)。

它的解决办法是：
1. 比特币的发行是由**挖矿**决定的，
2. 依靠区块链的数据结构。

<Image src="/xiaozhen/03-btc-transaction-method.png" alt="btc-transaction-method" width={720} height={720} />

如上图，比特币的发行者 A 拥有**铸币权(createcoin)**，假如发行 10 个比特币，A(10) 分别给 B 和 C 各五个 `A(10) → B(5)C(5)`， 该交易需要有 A 的签名，证明经 A 同意(signed by A)。同时还要说明花掉的 10 个比特币从哪来的。我们可以看到第二个方框中 A 的钱是从第一个框内铸币交易中来的。

比特币系统中每个交易都包含**输入**和**输出**两部分。输入部分要说明币的来源，输出部分要给出收款人公钥的哈希。

有的交易部分比较复杂，如 C 的货币来源是第二、第三个方框的交易，要标识清楚。

上图就构成了一个小型的区块链，这里有两种哈希指针，一种哈希指针是连接在各个区块之间的，把它们串起来构成一个链表，前面学的就是这种哈希指针。
而在该图中还有第二种哈希指针，是指向前面某个交易的指针，用来指明币的来源。

**为什么要说明币的来源？**：证明币不是凭空捏造的，是有记录的，同时也能**防范双花攻击(double spending attack)**。

现在来看第二个方框里 A 向 B 的转账，该交易需要 A 的签名和 B 的地址。**比特币系统里收款的地址是通过公钥推算出来的**。比如 B 的地址就是 B 的公钥取哈希，然后经过一些转换得到的。

**A 如何知道 B 的地址呢？** 比特币系统中没有查询对方地址的功能，必须通过其他渠道。比如某个电商网站，接受比特币支付，就可以公开它的地址或公钥。

**A 需要知道 B 的地址，B 需要知道 A 的什么信息吗？** B 其实也要知道 A 的公钥，这代表 A 的身份。不仅是 B，所有节点都需要知道 A 的公钥。而签名是用私钥签名、公钥验证(注意不要跟前面知识弄混了，加密是用接收人的公钥加密，私钥解密)，所以区块链上每个节点都要独立验证。

**那如何才能知道 A 的公钥？** 实际上交易里就包含了。输入时不仅要输入币的来源，还要输入公钥。那这就存在了安全漏洞，假如 B 的同伙伪造了这次交易呢？其实第一个方框里铸币交易的输出就有 A 的公钥的哈希，所以第二个方框交易里 A 的公钥要跟前面哈希对的上。

## 比特币脚本(BitCoinScript)

在比特币系统当中，前面这些验证过程，是通过执行脚本来实现的。每个交易的输入是一段脚本，包括给出公钥的过程，公钥也是在输入的脚本里指定的。每个交易的输出也是一段脚本，验证交易的合法性，它需要把当前交易的输入脚本跟前面交易(提供币来源的交易)的输出脚本拼在一起，然后看看能不能顺利执行，如果能执行说明是合法的。

上图是对交易系统进行的简化，实际上每个区块(对应图中的每个方框)可以有很多交易，这些交易组成默克尔树(merkle tree)。每个区块分为**块头**和**块身**。

## 区块
### 块头
块头包含的是区块的宏观信息，比如包含的域有：

- version - 用的是比特币哪个版本的协议
- hashPre - 区块链当中指向前一个区块的指针(hash of previous block header)
- merkleRootHash - 整颗 merkle tree 的根哈希值
- target - 挖矿的难度目标预值
- nonce - 随机数

这里的 target，就是前面讲到的，整个块头的哈希要小于这个域值，即 `H(block header)≤target`。block header 里存的就是这个目标预值的编码(nBits)。
这里需要注意，前一个区块的哈希只算的是前一个区块的块头，所以前面画的，一个区块引出一个箭头指向另一个区块中间，是不正确的，所以有的书箭头是指向一个区块的上面。
取哈希时，是把块头的所有部分都取哈希。

### 块身
块身里面有**交易列表(transaction list)**。

前面还有一个内容讲的时候简化了：每个节点都需要验证所有的交易，实际上系统中的节点分**全节点(full node)**和**轻节点(light node)**。

- 全节点是保存区块链所有的信息的，验证每一个交易，所以全节点又叫 **fully validating node**。
- 轻节点只保存 block header 的信息，一般来说轻节点没法独立验证交易的合法性。

比如一个交易是不是双花攻击(double spending attack)，轻节点没有存之前的所有交易信息，所以它没法验证。
系统中大多数节点是轻节点。我们现在主要讲的是全节点，因为轻节点没有参与区块链的构造和维护，只是利用了区块链的一些信息做一些查询。

**区块链里的内容是如何写到区块链里面的呢？** 每个节点，每个账户都可以发布交易，交易是广播给所有节点的。有些交易是合法的，有些是非法的。

**谁来决定哪些交易应该被写入下一个区块中呢？按照什么顺序写呢？如果每个节点自己决定，可以吗？** 如果每个人在本地维护一个区块链，那区块链的统一性得不到保证，而账本的内容是要取得分布式的共识(distributed consensus)。

下来，我们简要了解下分布式共识理论。

## 分布式共识理论(了解)

分布式共识一个简单的例子就是分布式的哈希表(distributed hash table)，比如系统里有很多台机器，共同维护一个全局的哈希表。

**这里需要取得共识的内容是什么？** 哈希表中包含了一些键值对(key valve pair)。假如有人在自己电脑上插入一个键值对，如 ‘xiao’ 这个键对应的是 12345，即 `'xiao'→12345`。
那么别人在另一台读的时候也要能把这个读出来，这就叫一个全局的哈希表。

关于分布式系统有很多**不可能理论(impossibility result)**，其中最著名的是 **FLP理论**。这三个字母是三个专家的名字缩写，他们的结论是：在一个 **异步(asynchronous)** 的系统
里(**网络传输迟延没有上限就叫异步系统**)，即使只有一个成员是有问题的(faulty)，也不可能取得共识。

还有一个著名理论：**CAP理论**。CAP 是指分布式系统中我们想要的三个性质：

- Consistency - 系统状态的一致性，
- Availability - 大家都能用的可用性，
- Partition tolerance - 分区容错性。

该理论内容是：**任何一个分布式系统，比如分布式哈希表，这三个性质中，最多只能满足两个，假如想要前两个性质，那么就不会得到第三个性质**。

比特币分布式共识一个著名的协议是 **Paxos**，该协议能够保证一致性，即第一个性质。如果该协议达成了共识，那么这个共识一定是一致的，即每个成员所认为的共识都是相同的。但是，某些情况下，该协议可能永远无法达成共识，这种可能性比较小但是客观存在的。

## 比特币共识协议(consensus in BitCoin)

比特币中共识要解决的一个问题是，有些节点可能是有恶意的。**我们假设系统中大多数节点是好的，那么该如何取得共识协议？**

第一种方案是**投票**，首先应该确定哪些区块有投票权，有些 membership 是有严格要求的，这种情况下基于投票的方案是可行的。
但比特币系统创建账户是很容易的，一个人产生公私钥对，别人是无法得知，只有转账时，别人才知道。所以有些人可以不停的创建账户，当超过账户总数的一半时就有了控制权，
这种行为称为**女巫攻击(sybil attack)**。因此投票方法不可取。

比特币账户巧妙的解决了这个问题，不是按照账户数目投票，而是按照**计算力**来投票。每个节点都可以在本地组装出一个候选区块，把它认为合法的交易放在里面，然后开始尝试
各种 nonce 值(占 4 byte)，找出能满足不等式 `H(block header)≤target` 的要求的 nonce 值。如果某个节点找到了符合要求的 nonce，它就获得了**记账权**。

**所谓的记账权**，就是往比特币账本里写入下一个区块的权利。只有找到这个 nonce，获得记账权的节点才有权利发布下一个区块。其他节点收到这个区块之后，要验证这个区块的合法性。

`H(block header)≤target`，如果括号里 block header 的内容填的不对，block header 里面有一个域，叫 nBits 域，实际上它是目标预值(target)的一个编码，检查一下 nBits 域设置的值
是不是符合比特币协议中规定的难度要求来判断该不等式是否成立。假设都符合要求，然后检查 block body 里面的交易列表，验证一下每个交易都是合法的：**1、要有合法的签名，2、之前没有被花费过**。
如果有一项不符合要求，这个区块就是不能被接受的。如果所有条件都符合，也不一定能被接受。

<Image  src="/xiaozhen/03-btc-transaction-chain.png" alt="btc-transaction-chain" height={720} width={720} />

看上图，假如生成了一个新区块，**怎么知道新区块插在了哪里呢？** 根据生成区块的上一个区块指针(hashPre)。

有可能存在一个问题是，看上图，这两个交易： A 转账给 B 以及 A 转账给自己(A’)。这种情况不是**双花攻击(double spending attack)**，
判断一个交易是不是双花攻击(double spending attack)，是看这个区块所在的分支上币有没有被花掉。如图，一直到第三个区块，币都没有花过，所以这两个交易都是合法的。
虽然交易都是合法的，但是转给自己的交易不在**最长合法链(longest valid chain)**上。这种行为常称之为**分叉攻击(forking attack)**。所以接收的区块应该是扩展最长合法链。

区块链在正常情况下也可能出现**分叉**：两个节点同时获得记账权。每个节点在本地自己组装一个它认为合适的区块，然后去试各种 nonce，如果两个节点在差不多同一个时间找到了符合要求的 nonce，
就都可以把区块发布，这时会出现两个等长的分叉。这两条都是最长合法链，那该接受哪条呢？比特币协议当中，在缺省(默认的意思)情况下，每个节点是接受它最早收到的那个。
所以不同节点根据在网络上的位置不同，有的节点先接收到新生成的其中一个区块，那就接受这个区块；有些节点先接收到另一个区块，那就接受另一个区块。

**如何判断接收了一个区块？** 比特币协议中用到了**隐性委托(implicit consign)**，如果沿着这个区块往下继续扩展，就算认可了这个发布的区块。
比如在新生成的其中一个区块后面又拓展一个区块，表明就认可了这个新区块。

等长的临时性的分叉会维持一段时间，直到一个分叉胜出。也就是哪一个链抢先一步生成了新的区块，哪一条就是最长合法链。
另一个作废的就叫**孤儿块(orphan block)**。这两个新区块有可能会各自拉拢，两个区块链看谁的算力强，有时候也是看谁的运气好，就会胜出。

竞争记账权的好处：首先获得记账权的节点本身有一定的权力，可以决定哪些交易写到下一个区块里。但这些不应该被设定为竞争记账权的动力，所以比特币巧妙地建立了一个机制：区块奖励(block reward)。

比特币协议中规定获得记账权的节点在发布的区块里可以有一个特殊的交易：**铸币交易**。在这个交易里可以获得一定数量的比特币。

这里要回到前面的问题—**—谁来决定货币的发行？币基交易(coinbase transaction)是比特币系统中发行新的比特币的唯一方法**，其他的交易都是比特币的转移。这个交易不用指出币的来源。

**那么能造多少币呢？** 开始时，比特币刚上线的时候，每一个发布的区块可以产生 50BTC(BTC 就是比特币的符号)。协议中规定，21 万个区块以后，出块奖励就要减半，
就变成了 25BTC。再过 21 万个区块，又要减半。

因此当一个区块胜出后，另一个作废的区块得到的比特币是没有作用的，其他诚实的区块是不会承认的。

**比特币系统中要取得什么共识？** 要取得去中心化的账本共识。

**谁又能决定账本的内容呢？** 只有获得记账权的节点才能写东西。**怎么获得记账权呢？** 就是解算力(挖矿)。按照算力记票，算力可以用每秒能试多少 nonce 数值表示。

**那怎样防范女巫攻击呢？** 按算力记票，即使创建再多的账户，也无法使算力增强。

比特币争夺记账权的过程叫作挖矿(mining)，比特币被称为数字黄金(digital gold)，争夺记账权的节点被称为矿工(miner)。