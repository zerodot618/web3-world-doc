import Image from 'next/image';

## 1. 排序算法介绍

排序也称之为排序算法(Sort Algorithm)，是讲一组数据以指定的顺序进行排列的过程。

### 1.1 排序分类
内部排序：
- 将所有的数据都加载到内部存储器上进行排序

外部排序：
- 数据量多大，无法全部加载到内存中，需要借助外部存储(文档)进行排序

算法分类图：

<Image src="/data-structure-and-algorithm/05-sort-algorithm-1.png" alt="sort-algorithm-1" width={720} height={720} />

## 2. 算法时间效率
### 2.1 度量一个程序执行时间的两种方法

**事后统计方法：**
这种方法可行，但存在两个问题：
1. 要想对设计的算法运行性能进行评测就需要实际去运行该程序，
2. 所得时间统计量依赖于计算机硬件、软件等因素，这种方式要在同一台计算机的相同状态下运行，才能比较出哪一个算法速度更快，更好。

**事前估算方法：**
通过分析某一个算法的时间复杂度来判断哪个算法更优，更好。

### 2.2 时间频度

时间频度：一个算法花费的时间与算法中语句的执行次数成正比，哪一个算法中语句执行次数多，那么他所花费的时间就会多。**一个算法中语句执行次数称之为语句频度或时间频**，记为 `T(n)`。

**计算要点：**
- 忽略常数项
- 忽略低次项
- 忽略系数

### 2.3 时间复杂度
在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大 `O` 符号表述，
不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，渐近时间复杂度又称之为时间复杂度。

<Image src="/data-structure-and-algorithm/05-sort-algorithm-2.png" alt="sort-algorithm-2" width={720} height={720} />

### 2.4 常见的时间复杂度
1. 常数时间

若对于一个算法的上界与输入大小无关，则称其具有**常数时间**，记作 `O(1)` 时间。

2. 对数时间

若算法的 `T(n) = O(logn)`，则称其具有**对数时间**。

3. 幂对数时间
对于某个常数 k，若算法的 `T(n) = O(logn)`，则称其具有**幂对数时间**。

4. 次线性时间

对于一个算法，若其匹配 `T(n) = O(n)`，则其时间复杂度为**次线性时间**(**sub-linear time** 或 **sublinear time**)。

5. 线性时间

如果一个算法的时间复杂度为 `O(n)`，则称这个算法具有线性时间，或 `O(n)` 时间。

6. 线性对数时间

若一个算法时间复杂度 `T(n) = O(nlogn)`，则称这个算法具有线性对数时间。

7. 指数时间

若 `T(n)` 是 2 为上界，起哄 poly(n) 是 n 的多项式，则算法被称为**指数时间**。

常见的时间复杂度对应图：

<Image src="/data-structure-and-algorithm/05-sort-algorithm-3.png" alt="sort-algorithm-3" width={720} height={720} />